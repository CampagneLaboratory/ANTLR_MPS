package org.campagnelab.antlr.parsers;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import java.awt.datatransfer.Transferable;
import com.intellij.ide.CopyPasteManagerEx;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import org.jetbrains.mps.openapi.module.SModule;
import org.antlr.ANTLRv4Lexer;
import org.antlr.v4.runtime.ANTLRInputStream;
import java.io.StringReader;
import org.antlr.ANTLRv4Parser;
import org.antlr.v4.runtime.CommonTokenStream;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.apache.log4j.Level;
import jetbrains.mps.util.MacrosFactory;
import javax.print.PrintException;
import jetbrains.mps.ide.datatransfer.SModelDataFlavor;

public class AntlrPaster {
  private static Logger LOG = LogManager.getLogger(AntlrPaster.class);
  public AntlrPaster() {
  }
  public void pasteRules(SNode anchor, IOperationContext operationContext, Project project) {
    String clipboardText = getStringFromClipboard();
    if (clipboardText == null) {
      return;
    }
    if (clipboardText.contains("lexer grammar") || clipboardText.contains("parser grammar")) {
      if (LOG_515473768.isInfoEnabled()) {
        LOG_515473768.info("Pasting clipboard text as full grammar");
      }
      pasteGrammarAsNodes(anchor, anchor.getModel(), clipboardText, operationContext, project);
    } else {
      if (LOG_515473768.isInfoEnabled()) {
        LOG_515473768.info("Pasting clipboard text as rules");
      }
      pasteRulesAsNodes(anchor, anchor.getModel(), clipboardText, operationContext, project);
    }
  }
  public void pasteJavaAsClass(SModel model, IOperationContext operationContext, Project project) {
    String javaCode = getStringFromClipboard();
    if (javaCode == null) {
      return;
    }
    pasteGrammarAsNodes(null, model, javaCode, operationContext, project);
  }
  public String getStringFromClipboard() {
    Transferable contents = null;
    for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
      if (trf != null && trf.isDataFlavorSupported(DataFlavor.stringFlavor)) {
        contents = trf;
      }
      break;
    }
    if (contents == null) {
      return null;
    }
    if (contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      try {
        Object data = contents.getTransferData(DataFlavor.stringFlavor);
        if (data instanceof String) {
          return (String) data;
        }
      } catch (UnsupportedFlavorException ex) {
        return null;
      } catch (IOException ex) {
        AntlrPaster.LOG.error(null, ex);
      }
    }
    return null;
  }
  public void pasteGrammarAsNodes(SNode anchor, SModel model, final String antlrRulesAsText, IOperationContext operationContext, Project project) {
    SModule module = model.getModule();
    try {
      ANTLRv4Lexer lexer = new ANTLRv4Lexer(new ANTLRInputStream(new StringReader(antlrRulesAsText)));
      ANTLRv4Parser parser = new ANTLRv4Parser(new CommonTokenStream(lexer));
      ANTLRv4Parser.GrammarSpecContext tree = parser.grammarSpec();
      // use the following to print types of nodes on the parse tree: 
      saveTreeAsPostScript(tree, parser);

      // initiate walk of tree with listener 
      SNode grammar = SNodeOperations.getNodeAncestor(anchor, MetaAdapterFactory.getConcept(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, "org.campagnelab.ANTLR.structure.Grammar"), true, false);
      try {
        AntlrRuleVisitor visitor = new AntlrRuleVisitor();
        SNode parsedGrammar = (SNode) visitor.visitGrammarSpec(tree);
        List<SNode> rules = (List<SNode>) SLinkOperations.getChildren(parsedGrammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x631eebe31132d83bL, "rules"));
        ListSequence.fromList(SLinkOperations.getChildren(grammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x631eebe31132d83bL, "rules"))).addSequence(ListSequence.fromList(rules));
        if (SLinkOperations.getTarget(grammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x7c18b9e171fc275L, "tokens")) == null) {
          SLinkOperations.setTarget(grammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x7c18b9e171fc275L, "tokens"), SLinkOperations.getTarget(parsedGrammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x7c18b9e171fc275L, "tokens")));
        } else {
          ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(grammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x7c18b9e171fc275L, "tokens")), MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x7c18b9e171f1505L, 0x7c18b9e171f2eb1L, "tokens"))).addSequence(ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(parsedGrammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x7c18b9e171fc275L, "tokens")), MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x7c18b9e171f1505L, 0x7c18b9e171f2eb1L, "tokens"))));
        }
        SPropertyOperations.set(grammar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), SPropertyOperations.getString(parsedGrammar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
      } catch (Exception e) {
        if (LOG_515473768.isEnabledFor(Level.ERROR)) {
          LOG_515473768.error("Exception when visiting parse tree.", e);
        }
      }

    } catch (IOException ioException) {
      if (LOG_515473768.isEnabledFor(Level.ERROR)) {
        LOG_515473768.error("Unable to paste ", ioException);
      }
    }
  }

  public void pasteRulesAsNodes(SNode anchor, SModel model, final String antlrRulesAsText, IOperationContext operationContext, Project project) {
    SModule module = model.getModule();
    try {
      ANTLRv4Lexer lexer = new ANTLRv4Lexer(new ANTLRInputStream(new StringReader(antlrRulesAsText)));
      ANTLRv4Parser parser = new ANTLRv4Parser(new CommonTokenStream(lexer));
      ANTLRv4Parser.RulesContext tree = parser.rules();
      // use the following to print types of nodes on the parse tree: 
      try {
        ((ANTLRv4Parser.RulesContext) tree).save(parser, MacrosFactory.getGlobal().expandPath("${ANTLR_HOME}/tree.ps"));

      } catch (PrintException e) {
        if (LOG_515473768.isEnabledFor(Level.ERROR)) {
          LOG_515473768.error("PrintException: ", e);
        }
      }

      // initiate walk of tree with listener 
      SNode grammar = SNodeOperations.getNodeAncestor(anchor, MetaAdapterFactory.getConcept(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, "org.campagnelab.ANTLR.structure.Grammar"), true, false);
      try {
        AntlrRuleVisitor visitor = new AntlrRuleVisitor();
        List<SNode> rules = (List<SNode>) visitor.visitRules(tree);
        ListSequence.fromList(SLinkOperations.getChildren(grammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x631eebe31132d83bL, "rules"))).addSequence(ListSequence.fromList(rules));
      } catch (Exception e) {
        if (LOG_515473768.isEnabledFor(Level.ERROR)) {
          LOG_515473768.error("Exception when visiting Rules parse tree.", e);
        }
      }

    } catch (IOException ioException) {
      if (LOG_515473768.isEnabledFor(Level.ERROR)) {
        LOG_515473768.error("Unable to paste ", ioException);
      }
    }
  }
  private void saveTreeAsPostScript(ANTLRv4Parser.GrammarSpecContext tree, ANTLRv4Parser parser) throws IOException {
    try {
      ((ANTLRv4Parser.GrammarSpecContext) tree).save(parser, MacrosFactory.getGlobal().expandPath("${ANTLR_HOME}/tree.ps"));

    } catch (PrintException e) {
      if (LOG_515473768.isEnabledFor(Level.ERROR)) {
        LOG_515473768.error("PrintException: ", e);
      }
    }
  }
  public static boolean areDataAvailableInClipboard() {
    Transferable trf = CopyPasteManagerEx.getInstanceEx().getContents();
    if (trf == null || trf.isDataFlavorSupported(SModelDataFlavor.sNode)) {
      return false;
    }
    if (trf.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      return true;
    }
    return false;
  }
  protected static Logger LOG_515473768 = LogManager.getLogger(AntlrPaster.class);
}
