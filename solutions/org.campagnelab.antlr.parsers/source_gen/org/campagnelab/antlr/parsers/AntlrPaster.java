package org.campagnelab.antlr.parsers;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import java.awt.datatransfer.Transferable;
import com.intellij.ide.CopyPasteManagerEx;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import org.jetbrains.mps.openapi.module.SModule;
import org.antlr.ANTLRv4Lexer;
import org.antlr.v4.runtime.ANTLRInputStream;
import java.io.StringReader;
import org.antlr.ANTLRv4Parser;
import org.antlr.v4.runtime.CommonTokenStream;
import jetbrains.mps.util.MacrosFactory;
import javax.print.PrintException;
import org.apache.log4j.Level;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import jetbrains.mps.ide.datatransfer.SModelDataFlavor;

public class AntlrPaster {
  private static Logger LOG = LogManager.getLogger(AntlrPaster.class);
  public AntlrPaster() {
  }
  public void pasteRules(SNode anchor, IOperationContext operationContext, Project project) {
    String antlrRuleText = getStringFromClipboard();
    if (antlrRuleText == null) {
      return;
    }
    pasteRulesAsNodes(anchor, anchor.getModel(), antlrRuleText, operationContext, project);
  }
  public void pasteJavaAsClass(SModel model, IOperationContext operationContext, Project project) {
    String javaCode = getStringFromClipboard();
    if (javaCode == null) {
      return;
    }
    pasteRulesAsNodes(null, model, javaCode, operationContext, project);
  }
  public String getStringFromClipboard() {
    Transferable contents = null;
    for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
      if (trf != null && trf.isDataFlavorSupported(DataFlavor.stringFlavor)) {
        contents = trf;
      }
      break;
    }
    if (contents == null) {
      return null;
    }
    if (contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      try {
        Object data = contents.getTransferData(DataFlavor.stringFlavor);
        if (data instanceof String) {
          return (String) data;
        }
      } catch (UnsupportedFlavorException ex) {
        return null;
      } catch (IOException ex) {
        AntlrPaster.LOG.error(null, ex);
      }
    }
    return null;
  }
  public void pasteRulesAsNodes(SNode anchor, SModel model, final String antlrRulesAsText, IOperationContext operationContext, Project project) {
    SModule module = model.getModule();
    try {
      ANTLRv4Lexer lexer = new ANTLRv4Lexer(new ANTLRInputStream(new StringReader(antlrRulesAsText)));
      ANTLRv4Parser parser = new ANTLRv4Parser(new CommonTokenStream(lexer));
      ANTLRv4Parser.RulesContext tree = parser.rules();
      // use the following to print types of nodes on the parse tree: 
      try {
        ((ANTLRv4Parser.RulesContext) tree).save(parser, MacrosFactory.getGlobal().expandPath("${ANTLR_HOME}/tree.ps"));

      } catch (PrintException e) {
        if (LOG_515473768.isEnabledFor(Level.ERROR)) {
          LOG_515473768.error("PrintException: ", e);
        }
      }

      // initiate walk of tree with listener 
      SNode grammar = SNodeOperations.getNodeAncestor(anchor, MetaAdapterFactory.getConcept(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, "org.campagnelab.ANTLR.structure.Grammar"), true, false);
      boolean useVisitor = true;
      if (useVisitor) {
        try {
          AntlrRuleVisitor visitor = new AntlrRuleVisitor();
          List<SNode> rules = (List<SNode>) visitor.visitRules(tree);
          ListSequence.fromList(SLinkOperations.getChildren(grammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x631eebe31132d83bL, "rules"))).addSequence(ListSequence.fromList(rules));

        } catch (Exception e) {
          if (LOG_515473768.isEnabledFor(Level.ERROR)) {
            LOG_515473768.error("Exception when visiting parse tree.", e);
          }
        }
      } else {
        ParseTreeWalker walker = new ParseTreeWalker();
        // create standard walker 
        ANTLRv4ParserListenerImpl extractor = new ANTLRv4ParserListenerImpl(parser);
        walker.walk(extractor, tree);
        ListSequence.fromList(SLinkOperations.getChildren(grammar, MetaAdapterFactory.getContainmentLink(0xd6782141eafa4cf7L, 0xa85d1229abdb1152L, 0x631eebe3113222a9L, 0x631eebe31132d83bL, "rules"))).addSequence(ListSequence.fromList(extractor.getRules()));
      }

    } catch (IOException ioException) {
      if (LOG_515473768.isEnabledFor(Level.ERROR)) {
        LOG_515473768.error("Unable to paste ", ioException);
      }
    }
  }
  public static boolean areDataAvailableInClipboard() {
    Transferable trf = CopyPasteManagerEx.getInstanceEx().getContents();
    if (trf == null || trf.isDataFlavorSupported(SModelDataFlavor.sNode)) {
      return false;
    }
    if (trf.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      return true;
    }
    return false;
  }
  protected static Logger LOG_515473768 = LogManager.getLogger(AntlrPaster.class);
}
